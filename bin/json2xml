#! /usr/bin/env python
from __future__ import unicode_literals
import sys
import os
import numbers
import re
import argparse
import json
import xml.etree.ElementTree as ET

try:
    basestring
except NameError:
    basestring = str                                        # pylint: disable=W0622

class Error(Exception):
    """Abstract base class for exceptions in this program."""

    return_value = 3

    def __init__(self, path):
        self.path = path

    def __str__(self):
        return "error at " + self.path

class DataTypeError(Error):
    """Exception raised for values with wrong type."""

    def __init__(self, path, type, value):
        Error.__init__(self, path)
        self.type = type
        self.value = value

    def __str__(self):
        return (Error.__str__(self) +
                ' - %s is not a valid value of "%s" type' % (repr(self.value), self.type))

class NodeTypeError(Error):
    """Exception raised if the JSON object type doesn't fit the data model."""

    def __init__(self, path, node_type):
        Error.__init__(self, path)
        self.node_type = node_type

    def __str__(self):
        return (Error.__str__(self) + " -  must be a " + self.node_type)

class InvalidNodeError(Error):
    """Exception raised for nodes that are not found in the data model."""

    def __str__(self):
        return (Error.__str__(self) + " - invalid node")

class JSONError(Error):
    """Exception raised for broken JSON input."""
    
    def __str__(self):
        return (self.path.__str__())

class Translator (object):
    """Translate JSON to XML according to a YANG data model.

    Instance variables:

    - `self.prefix`: dictionary mapping module names to prefix
    
    - `self.uri`: dictionary mapping module names to namespace URI

    - `self.qn_re`, self.num_re`, `self.bra_re`: compiled regular
      expressions.
    """

    def __init__(self, jtox):
        self.jtox = jtox
        self.prefix = {}
        self.uri = {}
        self.node_modules = set()
        for m in jtox["modules"]:
            self.prefix[m], self.uri[m] = jtox["modules"][m]
            ET.register_namespace(self.prefix[m], self.uri[m])
        ident = "[a-zA-Z_][-_.a-zA-Z0-9]*"
        self.qn_re = re.compile(r"^\s*(%s(?::%s)?)\s*(.*)$" % ((ident,)*2))
        self.num_re = re.compile(r"^\s*([0-9]+)\s*\]\s*(.*)$")
        self.bra_re = re.compile(r"""^=\s*([^"'\]\s]+|"[^"]*"|'[^']*')\s*\]\s*(.*)$""")

    def et_qname(self, mod_name, node_name):
        """Return the qualified node name as undestood by ElementTree."""
        return "{%s}%s" % (self.uri[mod_name], node_name)

    def translate(self, json_doc, xml_root):
        """Translate `json_doc` and attach the result under `xml_root`."""
        try:
            try:
                json_doc.fileno                               # Is it a file?
            except AttributeError:
                d = json.loads(json_doc)
            else:
                d = json.load(json_doc)
        except ValueError as e:
            raise JSONError(e)
        return self.translate_obj(d, None, self.jtox["tree"], xml_root, "/")
        
    def translate_obj(self, json_obj, ns, node, xml_parent, path):
        """Translate object and attach it to the output XML tree.

        Arguments:

        - `json_obj`: JSON object to translate,

        - `ns`: current namespace (module name)

        - `node`: corresponding schema node in the jtox driver structure,

        - `xml_parent`: parent XML element for the resulting tree

        - `path`: JSON pointer of `json_obj` (for error messages)
        
        """ 
        for key in json_obj:
            job = json_obj[key]
            new_path = path + key
            tag, mod_name, node_spec = self.node_lookup(key, ns, node, new_path)
            self.node_modules.add(mod_name)
            qn = self.et_qname(mod_name, tag)
            if node_spec[0] == "container":
                if not isinstance(job, dict):
                    raise NodeTypeError(new_path, "container")
                el = ET.SubElement(xml_parent, qn)
                self.translate_obj(job, mod_name, node_spec[1], el, new_path + "/")
            elif node_spec[0] == "list":
                if not isinstance(job, list) or job == [None]:
                    raise NodeTypeError(new_path, "list")
                i = 0
                for child in job:
                    if not isinstance(child, dict):
                        raise NodeTypeError(new_path, "list")
                    el = ET.SubElement(xml_parent, qn)
                    self.translate_obj(child, mod_name, node_spec[1],
                                       el, new_path + "/%d/" % i)
                    # Rearrange the subtree so that keys come first and in order
                    keys = node_spec[2]
                    keys.reverse()
                    for k in keys:
                        knode = el.find(self.et_qname(*k))
                        el.remove(knode)
                        el.insert(0,knode)
                    i += 1
            elif node_spec[0] == "leaf":
                self.handle_leaf(node_spec, job, ns, node_spec[1], mod_name,
                                 qn, xml_parent, new_path)
            elif node_spec[0] == "leaf-list":
                i = 0
                for child in job:
                    self.handle_leaf(node_spec, child, ns, node_spec[1], mod_name, qn,
                                     xml_parent, new_path + "/%d" % i)
                    i += 1
            elif node_spec[0] == "anyxml":
                el = ET.SubElement(xml_parent, qn)
                if isinstance(job, dict):
                    self.handle_anyxml(job, el)
                else:
                    el.text = str(job)

    def handle_leaf(self, node_spec, value, ns, ytyp, mod_name, leaf_name, xml_parent, path):
        """Install the transformed leaf with `value` under `xml_parent`."""
        tval = self.text_value(value, ns, ytyp, mod_name, path)
        if tval is None :
            tsp = ytyp[0] if isinstance(node_spec[1], list) else ytyp
            raise DataTypeError(path, tsp, value)
        el = ET.SubElement(xml_parent, leaf_name)
        el.text = tval

    def handle_anyxml(self, obj, parent):
        """Translate anyxml content from JSON object `obj` and attach under `el`."""
        for ch in obj:
            cobj = obj[ch]
            if isinstance(cobj, dict):
                el = ET.SubElement(parent, ch)
                self.handle_anyxml(cobj, el)
            elif isinstance(cobj, list):
                for eob in cobj:    
                    el = ET.SubElement(parent, ch)
                    if isinstance(eob, dict):
                        self.handle_anyxml(eob, el)
                    else:
                        el.text = str(eob)
            else:
                el = ET.SubElement(parent, ch)
                el.text = str(cobj)

    def node_lookup(self, name, ns, parent, path):
        """Return tag, module name and node specification for `name`."""
        fst, sep, snd = name.partition(":")
        try:
            spec = parent[name]
        except KeyError:
            if sep:
                try:
                    spec = parent[snd]
                except KeyError:
                    raise InvalidNodeError(path)
        if sep: return (snd, fst, spec)
        return (fst, ns, spec)

    def text_value(self, value, ns, type_spec, mod_name, path):
        """Return `value` translated to its XML form.

        Return `None` if `value` cannot be represented as an instance
        of the datatype specified by `type_spec`.

        Arguments:

        - `value`: leaf value as found in JSON;
        
        - `type_spec`: type specification produced by the "jtox" plugin;

        - `mod_name`: module name of the containing leaf

        - `path`: path of the node containing `value` (for error reporting)
        """
        def handle_int(value, bits, unsigned):
            try:
                if (bits == 64 and isinstance(value, basestring)
                    or isinstance(value, int) and not isinstance(value, bool)
                    or isinstance(value, numbers.Real) and value.is_integer()):
                    val = int(value)
                else:
                    return None
            except:
                return None
            if unsigned:
                lo = 0
                hi = 2 ** bits
            else:
                hi = 2 ** (bits-1)
                lo = -hi
            return "%d" % val if lo <= val < hi else None  
        t = type_spec[0] if isinstance(type_spec, list) else type_spec 
        if t == 'empty':
            return "" if value == [None] else None
        if t[0:3] == "int":
            return handle_int(value, int(t[3:]), False) 
        if t[0:4] == "uint":
            return handle_int(value, int(t[4:]), True) 
        if t == "decimal64":
            if not isinstance(value, basestring): return None
            ip, dp, fp = value.partition('.')
            try:
                if dp:
                    fp = fp.rstrip("0")
                    if len(fp) > type_spec[1]:
                        return None
                    ival = int(ip + fp)
                else:
                    ival = int(ip)
            except ValueError:
                return None
            hi = 2 ** 63
            lo = -hi
            return ip + dp + fp if lo <= ival < hi else None
        if t == "boolean":
            if value is True:
                return "true"
            elif value is False:
                return "false"
            else:
                return None
        if t == "union":
            for memb in type_spec[1]:
                tval = self.text_value(value, ns, memb, mod_name, path)
                if tval is not None: return tval
            return None
        if t == "identityref":
            try:
                fst, sep, snd = value.partition(":")
                if sep:
                    m = fst
                    idv = snd
                else:
                    m = mod_name
                    idv = value
                return "%s:%s" % (self.prefix[m], idv)
            except:
                return None
        if t == "instance-identifier":
            result = ""
            node = self.jtox["tree"]
            try:
                rest = value.strip()
                m = None
                while len(rest) > 0:
                    result += rest[0]
                    zb = rest[1:]
                    if rest[0] == "/":
                        mo = self.qn_re.search(zb)
                        t, m, spec = self.node_lookup(mo.group(1), m, node, path)
                        result += self.prefix[m] + ":" + t
                        rest = mo.group(2)
                        if spec[0] in ("container", "list"):
                            node = spec[1]
                    elif rest[0] == "[":
                        mo = self.num_re.search(zb)
                        if mo is None:
                            mo = self.qn_re.search(zb)
                            t, m, spec = self.node_lookup(mo.group(1), m, node, path)
                            result +=  self.prefix[m] + ":" + t + "="
                            mo = self.bra_re.search(mo.group(2))
                        result += mo.group(1).strip() + "]"
                        rest = mo.group(2)
                    else:
                        return None
            except:
                return None
            return result
        return str(value)

def main():
    """Parse arguments, open files, create and run the translator."""
    parser = argparse.ArgumentParser(
        description="JSON to XML conversion driven by a YANG data model.")
    parser.add_argument("jtox", metavar="driver_file", action="store",
                        help="driver file produced by YANG plugin 'jtox'")
    parser.add_argument("json", metavar='json_file', action="store",
                        help="JSON instance document (or '-' for standard input)")
    parser.add_argument("-t", "--target", action="store", default="data",
                        help="type of the resulting XML document (default: data)")
    parser.add_argument("-o", "--output", action="store",
                        help="output file (default: standard output)") 
    args = parser.parse_args()
    if args.target not in ["data", "config"]:
        sys.stderr.write("%s: error: unknown target '%s'\n" % (parser.prog, args.target))
        return 2
    try:
        dfile = open(args.jtox)
        jfile = sys.stdin if args.json == "-" else open(args.json)
        if args.output is None:
            outfile = os.fdopen(sys.stdout.fileno(), "wb")
        else:
            outfile = open(args.output, "wb")
        jtox = json.load(dfile)
    except IOError as e:
        sys.stderr.write("%s: error: %s: '%s'\n" %
                         (parser.prog, e.strerror,e.filename))
        return 1
    except ValueError as e:
        sys.stderr.write("%s: error: %s\n" %
                         (parser.prog, e.message))
        return 1
    nc_uri = "urn:ietf:params:xml:ns:netconf:base:1.0"
    ET.register_namespace("nc", nc_uri)
    root_el = ET.Element("{%s}%s" % (nc_uri, args.target))
    trans = Translator(jtox)
    try:
        trans.translate(jfile, root_el)
    except Error as e:
        sys.stderr.write(parser.prog + ": " + str(e) + "\n")
        return e.return_value
    for m in set(trans.prefix.keys()) - trans.node_modules:
        root_el.attrib["xmlns:" + trans.prefix[m]] = trans.uri[m]
    ET.ElementTree(root_el).write(outfile, encoding="utf-8", xml_declaration=True)
    return 0

if __name__ == "__main__":
    sys.exit(main())
